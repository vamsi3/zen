"use strict";(self.webpackChunkzen=self.webpackChunkzen||[]).push([[9805],{3905:function(t,n,e){e.d(n,{Zo:function(){return l},kt:function(){return y}});var r=e(7294);function o(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function a(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){o(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function u(t,n){if(null==t)return{};var e,r,o=function(t,n){if(null==t)return{};var e,r,o={},i=Object.keys(t);for(r=0;r<i.length;r++)e=i[r],n.indexOf(e)>=0||(o[e]=t[e]);return o}(t,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(r=0;r<i.length;r++)e=i[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(o[e]=t[e])}return o}var c=r.createContext({}),m=function(t){var n=r.useContext(c),e=n;return t&&(e="function"==typeof t?t(n):a(a({},n),t)),e},l=function(t){var n=m(t.components);return r.createElement(c.Provider,{value:n},t.children)},s={inlineCode:"code",wrapper:function(t){var n=t.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(t,n){var e=t.components,o=t.mdxType,i=t.originalType,c=t.parentName,l=u(t,["components","mdxType","originalType","parentName"]),p=m(e),y=o,_=p["".concat(c,".").concat(y)]||p[y]||s[y]||i;return e?r.createElement(_,a(a({ref:n},l),{},{components:e})):r.createElement(_,a({ref:n},l))}));function y(t,n){var e=arguments,o=n&&n.mdxType;if("string"==typeof t||o){var i=e.length,a=new Array(i);a[0]=p;var u={};for(var c in n)hasOwnProperty.call(n,c)&&(u[c]=n[c]);u.originalType=t,u.mdxType="string"==typeof t?t:o,a[1]=u;for(var m=2;m<i;m++)a[m]=e[m];return r.createElement.apply(null,a)}return r.createElement.apply(null,e)}p.displayName="MDXCreateElement"},3584:function(t,n,e){e.r(n),e.d(n,{frontMatter:function(){return u},contentTitle:function(){return c},metadata:function(){return m},toc:function(){return l},default:function(){return p}});var r=e(7462),o=e(3366),i=(e(7294),e(3905)),a=["components"],u={title:"Montgomery Space",sidebar_label:"Montgomery Space"},c=void 0,m={unversionedId:"cp/math/montgomery",id:"cp/math/montgomery",isDocsHomePage:!1,title:"Montgomery Space",description:"",source:"@site/docs/cp/math/montgomery.mdx",sourceDirName:"cp/math",slug:"/cp/math/montgomery",permalink:"/zen/cp/math/montgomery",editUrl:"https://github.com/vamsi3/zen/edit/master/docs/cp/math/montgomery.mdx",tags:[],version:"current",lastUpdatedAt:1634748217,formattedLastUpdatedAt:"10/20/2021",frontMatter:{title:"Montgomery Space",sidebar_label:"Montgomery Space"},sidebar:"cp",previous:{title:"Integers in Modular Arithmetic",permalink:"/zen/cp/math/modint"},next:{title:"NTT",permalink:"/zen/cp/math/ntt"}},l=[],s={toc:l};function p(t){var n=t.components,e=(0,o.Z)(t,a);return(0,i.kt)("wrapper",(0,r.Z)({},s,e,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <ranges>\n\nnamespace Montgomery {\n\n    static constinit const uint64_t MOD = 1e9 + 7;\n\n    static std::tuple<uint64_t, uint64_t> mult(uint64_t x, uint64_t y) {\n        uint32_t a = x >> 32, b = x, c = y >> 32, d = y;\n        uint64_t ac = uint64_t(a) * c;\n        uint64_t ad = uint64_t(a) * d;\n        uint64_t bc = uint64_t(b) * c;\n        uint64_t bd = uint64_t(b) * d;\n        uint64_t lo = bd + (ad << 32) + (bc << 32);\n        uint64_t hi = (((bd >> 32) + uint32_t(ad) + uint32_t(bc)) >> 32)\n                        + (ad >> 32) + (bc >> 32) + ac;\n        return {hi, lo};\n    }\n\n    uint64_t to_montogomery(uint64_t);\n    uint64_t from_montogomery(uint64_t);\n    uint64_t mult_montogomery(uint64_t, uint64_t);\n\n    static constinit const uint64_t INV = [] {\n        uint64_t inv = 1;\n        for (auto _ : std::views::iota(0, 6)) inv *= 2 - MOD * inv;\n        return inv;\n    }();\n\n    static const uint64_t R_SQ = [] {\n        uint64_t r_sq = -MOD % MOD;\n        for (auto _ : std::views::iota(0, 4)) {\n            r_sq <<= 1;\n            if (r_sq >= MOD) r_sq -= MOD;\n        }\n        for (auto _ : std::views::iota(0, 4)) r_sq = mult_montogomery(r_sq, r_sq);\n        return r_sq;\n    }();\n\n    uint64_t to_montogomery(uint64_t x) {\n        return mult_montogomery(x, R_SQ);\n    }\n\n    uint64_t from_montogomery(uint64_t x) {\n        return MOD - std::get<0>(mult(x * INV, MOD));\n    }\n\n    uint64_t mult_montogomery(uint64_t x, uint64_t y) {\n        auto [hi, lo] = mult(x, y);\n        int64_t v = int64_t(hi) - std::get<0>(mult(lo * INV, MOD));\n        return (v >= 0) ? v : v + MOD;\n    }\n\n}\n\nint main() {\n    auto a = Montgomery::to_montogomery(31);\n    auto b = Montgomery::to_montogomery(17);\n    auto an = Montgomery::mult_montogomery(a, b);\n    an = Montgomery::from_montogomery(an);\n    std::cout << an << std::endl;\n}\n")))}p.isMDXComponent=!0}}]);