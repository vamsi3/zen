"use strict";(self.webpackChunkzen=self.webpackChunkzen||[]).push([[2936],{3905:function(t,n,e){e.d(n,{Zo:function(){return u},kt:function(){return v}});var r=e(7294);function i(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function o(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function a(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?o(Object(e),!0).forEach((function(n){i(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):o(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function c(t,n){if(null==t)return{};var e,r,i=function(t,n){if(null==t)return{};var e,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||(i[e]=t[e]);return i}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}var s=r.createContext({}),p=function(t){var n=r.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):a(a({},n),t)),e},u=function(t){var n=p(t.components);return r.createElement(s.Provider,{value:n},t.children)},m={inlineCode:"code",wrapper:function(t){var n=t.children;return r.createElement(r.Fragment,{},n)}},l=r.forwardRef((function(t,n){var e=t.components,i=t.mdxType,o=t.originalType,s=t.parentName,u=c(t,["components","mdxType","originalType","parentName"]),l=p(e),v=i,d=l["".concat(s,".").concat(v)]||l[v]||m[v]||o;return e?r.createElement(d,a(a({ref:n},u),{},{components:e})):r.createElement(d,a({ref:n},u))}));function v(t,n){var e=arguments,i=n&&n.mdxType;if("string"==typeof t||i){var o=e.length,a=new Array(o);a[0]=l;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=t,c.mdxType="string"==typeof t?t:i,a[1]=c;for(var p=2;p<o;p++)a[p]=e[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,e)}l.displayName="MDXCreateElement"},9796:function(t,n,e){e.r(n),e.d(n,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return u},default:function(){return l}});var r=e(7462),i=e(3366),o=(e(7294),e(3905)),a=["components"],c={title:"Modular Integer Class",sidebar_label:"Integers in Modular Arithmetic"},s=void 0,p={unversionedId:"cp/math/modint",id:"cp/math/modint",isDocsHomePage:!1,title:"Modular Integer Class",description:"- Iterative modular inverse//codeforces.com/blog/entry/64345?#comment-482502",source:"@site/docs/cp/math/modint.mdx",sourceDirName:"cp/math",slug:"/cp/math/modint",permalink:"/zen/cp/math/modint",editUrl:"https://github.com/vamsi3/zen/edit/master/docs/cp/math/modint.mdx",tags:[],version:"current",lastUpdatedAt:1635603104,formattedLastUpdatedAt:"10/30/2021",frontMatter:{title:"Modular Integer Class",sidebar_label:"Integers in Modular Arithmetic"},sidebar:"cp",previous:{title:"M\xf6bius function",permalink:"/zen/cp/math/mobius"},next:{title:"Montgomery Space",permalink:"/zen/cp/math/montgomery"}},u=[],m={toc:u};function l(t){var n=t.components,e=(0,i.Z)(t,a);return(0,o.kt)("wrapper",(0,r.Z)({},m,e,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"reference")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("ul",{parentName:"div"},(0,o.kt)("li",{parentName:"ul"},"Iterative modular inverse: ",(0,o.kt)("a",{parentName:"li",href:"https://codeforces.com/blog/entry/64345?#comment-482502"},"https://codeforces.com/blog/entry/64345?#comment-482502"))))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'namespace Math {\n    template<int32_t MOD_> class Mint {\n        static_assert(MOD_ > 0, "MOD must be positive");\n\n    private:\n        int32_t v;\n\n    public:\n        static constexpr int32_t MOD = MOD_;\n        constexpr Mint() : v(0) {}\n        constexpr Mint(int32_t v_) : v(v_ % MOD) { if (v < 0) v += MOD; }\n        constexpr Mint(int64_t v_) : v(static_cast<int32_t>(v_ % MOD)) { if (v < 0) v += MOD; }\n        explicit operator int() const { return v; }\n        friend std::ostream& operator << (std::ostream& os, const Mint& n) { return os << int(n); }\n        friend std::istream& operator >> (std::istream& is, Mint& n) { int64_t v_; is >> v_; n = Mint(v_); return is; }\n        friend bool operator == (const Mint& a, const Mint& b) { return a.v == b.v; }\n        friend bool operator != (const Mint& a, const Mint& b) { return a.v != b.v; }\n  \n        Mint  operator +  ()    { return Mint(*this); }\n        Mint  operator -  ()    { Mint n; n.v = v ? MOD - v : 0; return n; }\n        Mint& operator ++ ()    { ++v; if (v == MOD) v = 0; return *this; }\n        Mint& operator -- ()    { if (v == 0) v = MOD; --v; return *this; }\n        Mint  operator ++ (int) { Mint n(*this); operator++(); return n; }\n        Mint  operator -- (int) { Mint n(*this); operator--(); return n; }\n  \n        Mint& operator += (const Mint &o) { if ((v += o.v) >= MOD) v -= MOD; return *this; }\n        Mint& operator -= (const Mint &o) { if ((v -= o.v) < 0) v += MOD; return *this; }\n        Mint& operator *= (const Mint &o) { auto r = static_cast<int64_t>(v) * o.v; v = static_cast<int32_t>((r >= MOD) ? r % MOD : r); return *this; }\n        Mint& operator /= (const Mint &o) { return *this *= o.inv(); }\n  \n        friend Mint operator + (Mint a, const Mint &b) { return a += b; }\n        friend Mint operator - (Mint a, const Mint &b) { return a -= b; }\n        friend Mint operator * (Mint a, const Mint &b) { return a *= b; }\n        friend Mint operator / (Mint a, const Mint &b) { return a /= b; }\n  \n        Mint pow(int64_t b) const { Mint a(*this), r; r.v = 1; for (b %= (MOD - 1); b > 0; b >>= 1) { if (b & 1) r *= a; a *= a; } return r; }\n        \n        /**\n         *  @brief: See extended euclid algorithm iterative version to understand this logic below.\n         */\n        Mint inv() const {\n            int32_t a1 = MOD, a2 = v, v1 = 0, v2 = 1;\n            while (a2) {\n                int32_t q = a1 / a2;\n                a1 -= q * a2; swap(a1, a2);\n                v1 -= q * v2; swap(v1, v2);\n            }\n            return Mint(v1);\n        }\n  \n        /**\n         *  @brief: works when MOD is a prime of the form 1+(p*(2^k)), where p is a prime and k > 0. (verification needed?)\n         */\n        static Mint primitiveRoot() {\n            if (MOD == 998244353) return 3;\n            int32_t divisor_2 = 1 << std::countr_zero(static_cast<uint32_t>(MOD - 1));\n            int32_t phi_mod_by_2 = (MOD - 1) / 2;\n            Mint root = 2;\n            while (!(root.pow(divisor_2) != 1 && root.pow(phi_mod_by_2) != 1)) ++root;\n            return root;\n        }\n    };\n}\n\nconstexpr int MOD = 998244353;\nusing Mint = Math::Mint<MOD>;\n')))}l.isMDXComponent=!0}}]);