"use strict";(self.webpackChunkzen=self.webpackChunkzen||[]).push([[9524],{7942:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>d});var n=r(959);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var u=n.createContext({}),s=function(e){var t=n.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},p=function(e){var t=s(e.components);return n.createElement(u.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(r),g=i,d=c["".concat(u,".").concat(g)]||c[g]||h[g]||a;return r?n.createElement(d,o(o({ref:t},p),{},{components:r})):n.createElement(d,o({ref:t},p))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=g;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<a;s++)o[s]=r[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}g.displayName="MDXCreateElement"},8402:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var n=r(8957),i=(r(959),r(7942));const a={title:"Euler Path & Euler Circuit",sidebar_label:"Euler Tour"},o=void 0,l={unversionedId:"cp/graph/euler-tour",id:"cp/graph/euler-tour",title:"Euler Path & Euler Circuit",description:"1. https://en.wikipedia.org/wiki/Eulerianpath",source:"@site/docs/cp/graph/euler-tour.mdx",sourceDirName:"cp/graph",slug:"/cp/graph/euler-tour",permalink:"/zen/cp/graph/euler-tour",draft:!1,editUrl:"https://github.com/vamsi3/zen/edit/master/docs/cp/graph/euler-tour.mdx",tags:[],version:"current",lastUpdatedAt:1694358037,formattedLastUpdatedAt:"Sep 10, 2023",frontMatter:{title:"Euler Path & Euler Circuit",sidebar_label:"Euler Tour"},sidebar:"cp",previous:{title:"Edge Coloring",permalink:"/zen/cp/graph/edge-coloring"},next:{title:"Graph Class",permalink:"/zen/cp/graph/graph-class"}},u={},s=[{value:"Hierholzer&#39;s algorithm",id:"hierholzers-algorithm",level:3}],p={toc:s},c="wrapper";function h(e){let{components:t,...r}=e;return(0,i.kt)(c,(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"RESOURCES",type:"note"},(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Eulerian_path"},"https://en.wikipedia.org/wiki/Eulerian_path")))),(0,i.kt)("h3",{id:"hierholzers-algorithm"},"Hierholzer's algorithm"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This algorithm itself assumes that euler path / circuit exists ",(0,i.kt)("em",{parentName:"p"},"i.e.")),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"The graph is connected"),(0,i.kt)("li",{parentName:"ul"},"The number of vertices with odd degree is either 0 or 2.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"If it is 2, this algorithm gives euler path."),(0,i.kt)("li",{parentName:"ul"},"If it is 0, this algorithm gives euler circuit (without repeating start vertex)."))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Choose any starting vertex v, and follow a trail of edges from that vertex until returning to v. It is not possible to get stuck at any vertex other than v, because the even degree of all vertices ensures that, when the trail enters another vertex w there must be an unused edge leaving w. The tour formed in this way is a closed tour, but may not cover all the vertices and edges of the initial graph."),(0,i.kt)("li",{parentName:"ul"},"As long as there exists a vertex u that belongs to the current tour but that has adjacent edges not part of the tour, start another trail from u, following unused edges until returning to u, and join the tour formed in this way to the previous tour."),(0,i.kt)("li",{parentName:"ul"},"Since we assume the original graph is connected, repeating the previous step will exhaust all edges of the graph.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const int N = 2e5 + 5;\nset<int> g[N];\nvector<int> eu;\n\n/*\n * Warning: This function alters 'g';\n */\nvoid euler(int u) {\n  while (!g[u].empty()) {\n    int v = *g[u].begin();\n    g[u].erase(v); g[v].erase(u);\n    euler(v);\n  }\n  eu.push_back(u);\n}\n\nvoid solve() {\n  cin >> n >> m;\n  for (int i = 0; i < m; ++i) {\n    int u, v; cin >> u >> v;\n    g[u].insert(v); g[v].insert(u);\n  }\n  euler(1); // any start vertex is fine for circult\n  // for finding a tour, this vertex called MUST BE one of the two odd degree vertices.\n}\n")))}h.isMDXComponent=!0}}]);