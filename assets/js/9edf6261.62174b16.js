"use strict";(self.webpackChunkzen=self.webpackChunkzen||[]).push([[4810],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=a.createContext({}),c=function(e){var n=a.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(p.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),h=i,_=u["".concat(p,".").concat(h)]||u[h]||l[h]||o;return t?a.createElement(_,r(r({ref:n},d),{},{components:t})):a.createElement(_,r({ref:n},d))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=u;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3673:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return d},default:function(){return u}});var a=t(7462),i=t(3366),o=(t(7294),t(3905)),r=["components"],s={title:"Binary Heap"},p=void 0,c={unversionedId:"cp/data-structures/heap/binary-heap",id:"cp/data-structures/heap/binary-heap",title:"Binary Heap",description:"What is the run-time algorithmic complexity of calling heapifyDown on every non-leaf node in a complete tree of n nodes?",source:"@site/docs/cp/data-structures/heap/binary-heap.mdx",sourceDirName:"cp/data-structures/heap",slug:"/cp/data-structures/heap/binary-heap",permalink:"/zen/cp/data-structures/heap/binary-heap",editUrl:"https://github.com/vamsi3/zen/edit/master/docs/cp/data-structures/heap/binary-heap.mdx",tags:[],version:"current",lastUpdatedAt:1639367548,formattedLastUpdatedAt:"12/13/2021",frontMatter:{title:"Binary Heap"},sidebar:"cp",previous:{title:"Vector",permalink:"/zen/cp/data-structures/vector"},next:{title:"MinMax Heap",permalink:"/zen/cp/data-structures/heap/minmax-heap"}},d=[{value:"Priority Queue",id:"priority-queue",children:[],level:2},{value:"Priority Queue with Updates",id:"priority-queue-with-updates",children:[{value:"Example Usage",id:"example-usage",children:[],level:3}],level:2}],l={toc:d};function u(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"QUESTION")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},(0,o.kt)("strong",{parentName:"p"},"What is the run-time algorithmic complexity of calling ",(0,o.kt)("inlineCode",{parentName:"strong"},"heapifyDown")," on every non-leaf node in a complete tree of n nodes?")),(0,o.kt)("p",{parentName:"div"},"The run-time of calling ",(0,o.kt)("inlineCode",{parentName:"p"},"heapifyDown")," on a node is proportional to the height of the node. About half of the nodes are leaf nodes, about a quarter have height 1, about an eighth have height 2, about a sixteenth have height 3, and so on. This summation of heights converges to n, the number of nodes in the tree. Hence running ",(0,o.kt)("inlineCode",{parentName:"p"},"heapifyDown")," on every non-leaf node has a run-time complexity of ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."))),(0,o.kt)("h2",{id:"priority-queue"},"Priority Queue"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T, typename _Compare = less<T>>\nclass PriorityQueue {\n  using _Sequence = vector<T>;\n\nprotected:\n  _Sequence c;\n  _Compare comp;\n\nprivate:\n\n  /**\n   *  Similar to the textbook `heapifyDown` operation.\n   */\n  void _adjust_heap(const size_t first, size_t hole_index, const size_t len, const T value) {\n    size_t second_child = hole_index;\n\n    // This while loop goes down through nodes with two children\n    while (second_child < (len - 1) / 2) {\n      second_child = 2 * (second_child + 1);\n      if (comp(c[first + second_child], c[first + second_child - 1])) --second_child;\n      if (comp(c[first + second_child], value)) goto done;\n      c[first + hole_index] = c[first + second_child];\n      hole_index = second_child;\n    }\n\n    // This case checks if we ended up on a node with only one (left) child\n    // and that can happen only if there are even number of nodes.\n    if ((len & 1) == 0 && second_child == (len - 2) / 2) {\n      second_child = 2 * second_child + 1;\n      if (comp(c[first + second_child], value)) goto done;\n      c[first + hole_index] = c[first + second_child];\n      hole_index = second_child;\n    }\n\n    done:\n    c[first + hole_index] = value;\n  }\n\n  /**\n   *  @brief: Similar to std::make_heap\n   *  @param: Can add a `comp` parameter of type `_Compare` to pass the comparator.\n   *          This might make the function more similar to `std::make_heap`\n   */\n  void _make_heap(size_t first, size_t last) {\n    size_t len = last - first;\n    if (len < 2) return;\n\n    /** Note that approx. last half of nodes in heap are leaf nodes.\n     *  The following parent value denotes the index of highest non-leaf node\n     *  in (random-access) container `c`.\n     */\n    auto parent = (len / 2) - 1;\n\n    while (true) {\n      auto value = c[first + parent];\n      _adjust_heap(first, parent, len, value);\n      if (parent == 0) break;\n      --parent;\n    }\n  }\n\n  /**\n   *  @brief: Sometimes referred to as `heapifyUp`\n   *          This is similar to `std::push_heap`\n   *  @param: Can add a `comp` parameter of type `_Compare` to pass the comparator.\n   *          This might make the function more similar to `std::push_heap`\n   */\n  void _push_heap(size_t first, size_t last) {\n    auto value = c[last - 1];\n    size_t len = last - first;\n    size_t hole_index = len - 1;\n    size_t parent = (hole_index - 1) / 2;\n    while (hole_index > 0 && comp(c[first + parent], value)) {\n      c[first + hole_index] = c[first + parent];\n      hole_index = parent;\n      parent = (hole_index - 1) / 2;\n    }\n    c[first + hole_index] = value;\n  }\n\n  /**\n   *  @brief: Its just a swap of values and heapifyDown.\n   *          This is similar to std::pop_heap\n   *  @param: Can add a `comp` parameter of type `_Compare` to pass the comparator.\n   *          This might make the function more similar to `std::pop_heap`\n   */\n  void _pop_heap(size_t first, size_t last) {\n    size_t len = last - first;\n    if (len < 2) return;\n    --last; --len;\n    auto value = c[last];\n    c[last] = c[first]; // This is not necessary. Just ensures the discarded value is at end of tree / containter.\n    _adjust_heap(first, 0, len, value);\n  }\n\npublic:\n  PriorityQueue() {}\n  PriorityQueue(const _Sequence& __s) : c(__s)        { _make_heap(0, c.size()); }\n  PriorityQueue(_Sequence&& __s) : c(std::move(__s))  { _make_heap(0, c.size()); }\n\n  bool empty() const { return c.empty(); }\n  size_t size() const { return c.size(); }\n  const T& top() const { return c.front(); }\n\n  void push(const T& __x) {\n    c.push_back(__x);\n    _push_heap(0, c.size());\n  }\n  void push(T&& __x) {\n    c.push_back(std::move(__x));\n    _push_heap(0, c.size());\n  }\n  void pop() {\n    _pop_heap(0, c.size());\n    c.pop_back();\n  }\n};\n")),(0,o.kt)("h2",{id:"priority-queue-with-updates"},"Priority Queue with Updates"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"template<typename T, typename _Compare = less<pair<T, int32_t>>>\nclass PriorityQueue {\n  using Node = pair<T, int32_t>;\n\nprotected:\n  int32_t n = 0;\n  std::vector<Node> c;\n  std::vector<int32_t> p; // p maps an id of node to the node's index in c\n  _Compare comp;\n\nprivate:\n  void _assign_node(size_t index, const Node& value) {\n    c[index] =  std::move(value);\n    p[c[index].second] = index;\n  }\n\n  void _sift_up(size_t hole_index) {\n    if (n <= 1) return;\n    auto value = std::move(c[hole_index]);\n    size_t parent = (hole_index - 1) / 2;\n    while (hole_index > 0 && comp(c[parent], value)) {\n      _assign_node(hole_index, c[parent]);\n      hole_index = parent;\n      parent = (hole_index - 1) / 2;\n    }\n    _assign_node(hole_index, value);\n  }\n\n  void _sift_down(size_t hole_index) {\n    if (n <= 1) return;\n    auto value = std::move(c[hole_index]);\n    size_t second_child = hole_index;\n    while (second_child < n / 2) {\n      second_child = 2 * (second_child + 1);\n      if (second_child >= n || comp(c[second_child], c[second_child - 1])) --second_child;\n      if (comp(c[second_child], value)) break;\n      _assign_node(hole_index, c[second_child]);\n      hole_index = second_child;\n    }\n    _assign_node(hole_index, value);\n  }\n\n  void _make_heap() {\n    if (n < 2) return;\n    auto parent = (n / 2) - 1;\n    while (true) {\n      _sift_down(parent);\n      if (parent == 0) break;\n      --parent;\n    }\n  }\n\n  void _pop_heap(size_t pos) {\n    if (pos >= n) return; --n;\n    c[pos] = std::move(c[n]);\n    c.pop_back();\n    _sift_down(pos);\n  }\n\n  void _adjust_heap(size_t pos) {\n    auto parent = (pos - 1) / 2;\n    if (pos > 0 && comp(c[parent], c[pos])) _sift_up(pos);\n    else _sift_down(pos);\n  }\n\npublic:\n  PriorityQueue() {}\n  PriorityQueue(const std::vector<T>& __s) { for (const auto &x : __s) { c.emplace_back(x, n); p.push_back(n++); } _make_heap(); }\n  PriorityQueue(std::vector<T>&& __s) { for (const auto &x : __s) { c.emplace_back(std::move(x), n); p.push_back(n++); } _make_heap(); }\n\n  bool empty() const { return c.empty(); }\n  size_t size() const { return n; }\n  const T& top() const { return c.front().first; }\n\n  int32_t push(const T& __x) { c.emplace_back(__x, n); p.push_back(n);  _sift_up(n); return n++; }\n  int32_t push(T&& __x) { c.emplace_back(std::move(__x), n); p.push_back(n); _sift_up(n); return n++; }\n  void pop() { _pop_heap(0); }\n  void pop(size_t id) { _pop_heap(p[id]); }\n  void update(size_t id, const T& __x) { int pos = p[id]; c[pos].first = __x; _adjust_heap(pos); }\n  void update(size_t id, T&& __x) { int pos = p[id]; c[pos].first = std::move(__x); _adjust_heap(pos); }\n};\n")),(0,o.kt)("h3",{id:"example-usage"},"Example Usage"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"inline void solve() {\n  PriorityQueue<int> pq;\n  pq.push(4);\n  pq.push(-1);\n  pq.push(2);\n\n  int x = pq.push(1);\n  pq.update(x, -10);\n\n  while (!pq.empty()) {\n    cout << pq.top() << '\\n';\n    pq.pop();\n  }\n}\n")))}u.isMDXComponent=!0}}]);